"""Display data from an NWB file generated by acq4_to_NWB
    Handles opto mapping as stored by acq4_to_NWB.py
"""
import argparse
from dataclasses import dataclass
from pathlib import Path
from typing import Union

import matplotlib.patches as mpatches
import matplotlib.pyplot as mpl
import numpy as np
import pandas as pd
from matplotlib.collections import PatchCollection

from ephys.datareaders import acq4_reader
from ephys.mapanalysistools import compute_scores
from ephys.mini_analyses import minis_methods_common as MMC


class ReadAcq4:
    def __init__(self,  artifact_file: Union[str, Path, None] = None):
        self.artifact_file = artifact_file
        self.use_filtering = False

    def set_filters(self):
        self.use_filtering = True
        self.MA = MMC.MiniAnalyses()


    def readfile(self, f: Union[Path, str, None] = None):
        """_summary_

        Params
        ------
            f (Union[Path, str, None], optional): File path. Defaults to None.

        Returns
        -------
        Nothing
        """
        self.filename = f
        self.trace_counter = 0
        self.AR = acq4_reader.acq4_reader(f)
        self.AR.getData()
        if self.AR.tstart > 0.0:
            # end trace at start of the pulse
            self.maxindex = int(self.AR.tstart*self.AR.sample_rate[0])
        pulse_index = int(self.AR.tstart*self.AR.sample_rate[0])
        self.idata = self.AR.traces.view(np.ndarray).T
        if self.artifact_file is not None:
            art_data = pd.read_pickle(self.artifact_file)
            art_I = art_data["I"].T
            print("Subtracting artifact file")
            for i in range(self.idata.shape[1]):
                self.idata[:,i] -= art_I

        for i in range(self.idata.shape[1]):
            self.idata[pulse_index:, i] = self.idata[pulse_index-1, i]
        if self.use_filtering:
            # apply lpf and notch
            self.MA.dt_seconds = self.AR.sample_interval

            for i in range(self.idata.shape[1]):
                self.MA.reset_filtering()
                self.idata[:,i] = self.MA.LPFData(self.idata[:,i], 4000.)
                self.idata[:,i] = self.MA.NotchFilterData(self.idata[:,i], notch=[60., 120., 180., 240., 4000.], notch_Q=30. )

        self.command = self.AR.cmd_wave.view(np.ndarray).T
        self.timebase = self.AR.time_base.T
        self.AR.getLaserBlueCommand()
        self.laser_command = self.AR.LaserBlue_pCell.view(np.ndarray).T
        self.laser_timebase = self.AR.LaserBlue_time_base.view(np.ndarray).T
        self.AR.getScannerPositions()
        self.plot_traces(self.AR.mode, Path(self.AR.protocol).name)

    def onpick(self, event):

        self.trace_counter += 1
        zero_position = 100e-12*(self.trace_counter-1)
        lp = self.axs["E"].plot(self.timebase[:self.maxindex],
            self.idata[:self.maxindex, event.ind]+zero_position, linewidth=0.5)
        color = lp[0].get_color()  # get color of last trace
        self.axs["E"].text(x=0., y=zero_position,
            s=f"Spot {event.ind[0]:d}", color=color,
            fontdict = {"fontsize": 8, "fontweight": "normal",
            "va": "bottom", "ha": "left"})
        self.ELabel.set_text(f"Trace {event.ind[0]:d}")
        lpos = [self.AR.scanner_positions[event.ind, 0] / 1e3,
                self.AR.scanner_positions[event.ind, 1] / 1e3,]

        self.axs["D"].text(x=lpos[0], y = lpos[1], 
            s=f"{self.trace_counter:d}", 
            fontdict = {"fontsize": 8, "fontweight": "bold",
                "va": "center", "ha": "center"})
        self.fig.canvas.draw()
        self.fig.canvas.flush_events()

    def plot_traces(self, recmode: str, protocol: str):
        """Minimal plotter to show the data in an nwb file generated by acq4_to_NWB.py"""

        fig, axs = mpl.subplot_mosaic(
            [["A", "D"], ["A", "D"], ["A", "D"], ["A", "D"], ["B", "E"], ["C", "F"]],
            constrained_layout=True,
            figsize=(8, 10),
        )
        self.fig = fig
        self.axs = axs
        for ax in ["A", "B", "C", "E", "F"]:
            axs[ax].spines["right"].set_visible(False)
            axs[ax].spines["top"].set_visible(False)
        fig.suptitle(
            f"{str(self.filename):s}  {protocol:s}", fontsize=8, fontweight="demibold"
        )
        if "CCIV".casefold() in protocol.casefold() or protocol.startswith("Ic"):
            delta_I = 0.075
        elif protocol.startswith("Vc") or "Map".casefold() in protocol.casefold():
            delta_I = 100e-12
        else:
            raise ValueError(f"Protocol starting with : {protocol:s} not handled.")
        self.opto = False
        if "Map".casefold() in protocol.casefold():
            self.opto = True

        for i in range(self.AR.traces.shape[0]):
            axs["A"].plot(
                self.timebase[:self.maxindex],
                self.idata[:self.maxindex,i] + i * delta_I,
                linewidth=0.33,
            )
            axs["B"].plot(
                self.timebase[:self.maxindex],
                self.command[:self.maxindex, i],
                linewidth=0.33,
            )

            if self.opto:
                axs["C"].plot(
                    self.AR.LaserBlue_time_base[:self.maxindex,i], self.AR.LaserBlue_pCell[:self.maxindex,i]
                )
        axs["F"].plot(
            self.timebase[:self.maxindex],
            np.mean(self.idata[:self.maxindex], axis=1),
            linewidth=0.5,
        )
        self.trace_plot = axs["E"].plot(
            self.timebase[:self.maxindex],
            self.idata[:self.maxindex, 0],
            "g-",
            linewidth=0.5,
        )
        self.ELabel = self.axs["E"].text(
            0.05,
            0.95,
            f"Trace: {0:d}",
            ha="left",
            va="top",
            transform=self.axs["E"].transAxes,
        )
        axs["A"].set_xlabel("T (s)")
        axs["F"].set_xlabel("T (s)")
        if recmode.lower() in ["cc", "ic"]:
            axs["A"].set_ylabel("V (V)")
            axs["B"].set_ylabel("I (A)")
            axs["F"].set_ylabel("V (V)")
        elif recmode.lower() in ["vc"]:
            axs["A"].set_ylabel("I (A)")
            axs["B"].set_ylabel("V (V)")
            axs["F"].set_ylabel("mean I (A)")
        if self.opto is not None:
            axs["C"].set_xlabel("T (s)")
            axs["C"].set_ylabel("Intensity (AU)")

        # draw a map of the points by current
        if self.opto is not None:
            osize = float(self.AR.scanner_spotsize)/1e3 # match units with positions
            patches = []
            # create a circle to show the position of each stimulus
            for isp in range(self.AR.scanner_positions.shape[0]):
                circle = mpatches.Circle(
                    (
                        self.AR.scanner_positions[isp, 0] / 1e3,
                        self.AR.scanner_positions[isp, 1] / 1e3,
                    ),
                    radius=osize / 2.0,
                    color="blue",
                    ec="none",
                )
                patches.append(circle)
            collection = PatchCollection(patches, cmap=mpl.cm.cool, alpha=0.6)
            istim = int(0.5 * self.AR.sample_rate[0])
            onems = int(0.001 * self.AR.sample_rate[0])
            twentyms = 20 * onems
            grandmean, grandstd = compute_scores.grand_mean_std(self.AR.time_base, 
                self.AR.traces, window=[0.480, 0.5])
            print(grandmean, grandstd)
            zscores = compute_scores.ZScore2D(self.AR.time_base,
                self.AR.traces, pre_std=grandstd, pre_mean=grandmean,
                twin_base = [0.480, 0.5], twin_resp = [0.501, 0.531])
            # zscore = np.sum(
            #     self.AR.traces[:, istim : istim + twentyms], axis=0
            # ) - np.mean(
            #     self.AR.traces[:, istim - twentyms : istim], axis=0
            # )  # , np.linspace(0, 1, len(patches))
            colors = zscores / np.max(zscores)  # scale to 1.0
            collection.set_array(colors)
            collection.set_picker(True)
            axs["D"].add_collection(collection)
            axs["D"].set_facecolor("white")
            axs["D"].set_aspect("equal")
            axs["D"].scatter(
                np.mean(self.AR.scanner_positions[:, 0]) / 1e3,
                np.mean(self.AR.scanner_positions[:, 1] / 1e3),
                s=0.1,
                marker="o",
            )
            fig.canvas.mpl_connect("pick_event", self.onpick)

        mpl.show()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Display an NWB file")
    parser.add_argument(dest="inputfile", type=str, help="input filenbame")
    args = parser.parse_args()

    R = ReadAcq4()
    R.readfile(args.inputfile)
    # R.plot_traces()
