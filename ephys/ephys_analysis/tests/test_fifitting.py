""" Test the FI curve fitting.

"""
import numpy as np
import dataclasses
import sys
from typing import Union
import time
from dataclasses import dataclass, field
import pickle
from pathlib import Path
import numpy as np
import scipy.signal
import pyqtgraph as pg

import ephys.ephys_analysis.rm_tau_analysis as RMT
import ephys.ephys_analysis.spike_analysis as SA

from ephys.mini_analyses.util import UserTester

# set up for plotting
import matplotlib
import warnings  # need to turn off a scipy future warning.
import matplotlib.pyplot as mpl
from ephys.tools import fitting
# for reference - the HHIV data comes in with this class structure
@dataclass
class HHIV:  # mimics "Clamps" in spike and 
    mode:str = 'ic'
    traces: object=None
    cmd_wave: object=None
    values: object=None
    commandLevels: object=None  # for rmtau
    time_base: object=None
    tstart: float=0.02  # in seconds
    tend: float = 0.07  # in seconds
    tdur: float = 0.2  # in seconds
    sample_interval: float = 1e-5  # in seconds


testmode = False  # set false to hold graphs up until closed;
# true for 2 sec display
def printPars(pars):
    print(dir(pars))
    d = dataclasses.asdict(pars)
    for k in d.keys():
        print("k: ", k, " = ", d[k])

# these are the tests that will be run automagically

        # "fitOneOriginal",
        # "FIGrowthExpBreak",
        # "FIGrowthExp",
        # "piecewiselinear3",
        # "FIGrowthPower",

def test_FI_original():
    FITester(method="fitOneOriginal", plot=True)  # default method

# def test_fi_growth_exp_break():
#     FITester(method="FIGrowthExpBreak")

def test_fi_growth_exp():
    FITester(method="FIGrowthExp", plot=True)

# def test_fi_piecwiselinear3():
#     FITester(method="piecewiselinear3") 

# def test_fi_growth_power():
#     FITester(method="FIGrowthPower")

def test_fi_growth_Hill():
    FITester(method="Hill", plot=True)

def test_fi_slope():
    FITester(method="slope", plot=True)

def get_testdata(
):
    """
    The test data is generated by hh_sim
    Here we just read it

    """
    testpath = Path(__file__).parent # this assumes we are running in the same directory as the test data file

    with open(Path(testpath, "HHData.pkl"), "rb") as fh:
        IV = pickle.load(fh)  # should be a dict now
    IV = HHIV(**IV)
    return IV

def run_FI_tester(method="FIGrowthExpBreak", plot:bool=False):
    print("test_fi_fitting: run_FI_tester with method: ", method)
    "[Fzero, Ibreak, F1amp, F2amp, Irate]"
    # if method != "FIGrowthPower":
    # p = [0., 100e-12, 0, 400., 10e9]
    # x = np.arange(-1e-9, 1e-9+100e-12, 100e-12)
    # r = fitting.Fitting().FIGrowth1(p, x, y=None, C=None, sumsq=False, weights=None)
    # mpl.plot(x, r, 'o-')
    # mpl.show()
    # exit()
    # if method == "Hill":
    #     p = [100, 5e-10, 2]
    #     x = np.arange(-1e-9, 1e-9+100e-12, 100e-12)
    #     r = fitting.Fitting().Hill(p, x, y=None, C=None, sumsq=False, weights=None)
    #     mpl.plot(x, r, 'o-')
    #     mpl.show()
    #     exit()


    testdata  = get_testdata()
    spike_analyzer = SA.SpikeAnalysis()
    spike_analyzer.setup(clamps = testdata, threshold=-0.030, verbose=True)
    spike_analyzer.set_detector("Kalluri") # Kalluri is probably the best detector
    spike_analyzer.analyzeSpikes()
    testresult = spike_analyzer.analysis_summary
    spike_analyzer.analyzeSpikeShape(max_spike_shape=3, printSpikeInfo=False)
    spksh = spike_analyzer.spikeShapes
    if method != "slope":
        spike_analyzer.fitOne(
            i_inj=testresult["FI_Curve"][0],
            spike_count=testresult["FI_Curve"][1],
            pulse_duration = spike_analyzer.analysis_summary["pulseDuration"],
            info="",
            function=method,
            fixNonMonotonic=True,
            excludeNonMonotonic=False,
            max_current = None,
        )
    else:
        minI = 100e-12
        maxI = 500e-12
        slope_result = spike_analyzer.getFISlope(
            i_inj=testresult["FI_Curve"][0],
            spike_count=testresult["FI_Curve"][1],
            pulse_duration = spike_analyzer.analysis_summary["pulseDuration"],
            min_current = minI,
            max_current = maxI,
        )


    tr_line = []
    if plot:
        fig, ax = mpl.subplots(1, 2, figsize=(8, 5))
        ax[0].set_title(f"FI curve for {method:s}")
        for i, t in enumerate(testdata.traces):
            tr_line.append(ax[0].plot(testdata.time_base, testdata.traces[i], linewidth=0.33))
            if i in spksh.keys():
                sh = spksh[i]
                for j in sh.keys():
                    l_color = tr_line[i][0].get_color()
                    ax[0].plot(sh[j].peak_T, sh[j].peak_V, 'o', color="red", markersize=3)
                    ax[0].plot(sh[j].trough_T, sh[j].trough_V, '^', color=l_color, markersize=3)
                    ap_t = testdata.time_base[sh[j].AP_beginIndex]
                    # mpl.plot(sh[j].left_halfwidth_T, sh[j].left_halfwidth_V, 'r_')
                    # mpl.plot(sh[j].right_halfwidth_T, sh[j].right_halfwidth_V, 'b_')
                    ax[0].plot([sh[j].left_halfwidth_T, sh[j].right_halfwidth_T], 
                             [sh[j].left_halfwidth_V, sh[j].right_halfwidth_V,], color=l_color,
                              marker='o', markersize=1, linestyle='-', linewidth=1)
        ax[1].plot(testresult["FI_Curve"][0], testresult["FI_Curve"][1]/spike_analyzer.analysis_summary["pulseDuration"],
                    'o-', color="black", markersize=3)

        if method != "slope":
            ax[1].plot(testresult["FI_Growth"][0]["fit"][0][0], testresult["FI_Growth"][0]["fit"][1][0], '--', color="red")
            # also plot the fit values at the actual data points
            ax[1].plot(testresult["FI_Growth"][0]["fit_at_data_points"][0],
                       testresult["FI_Growth"][0]["fit_at_data_points"][1], 's', color="magenta")
        else:  # slope - plot the line and indicate the slope
            x_sl = np.arange(minI, maxI, 5e-12)
            y_sl = slope_result.slope*x_sl + slope_result.intercept
            ax[1].plot(x_sl, y_sl, '--', color="blue")
            ax[1].set_title(f"slope = {1e-12*slope_result.slope:.2f} (SD: {1e-12*slope_result.stderr:.2f}) Hz/pA")
        mpl.show()
    return spksh

class FITester(UserTester):
    def __init__(self, method="FIGrowthExpBreak", extra=None, plot:bool=False):
        self.TM = None
        self.figure = None
        UserTester.__init__(self,  "%s_%s" % (method, "FI"), method)
        print("FI tester: ", method)
        # UserTester.__init__(self, "%s_%s" % (method, extra), method)
        # if you want to store different results by the "extra" parameter

    def run_test(self, method, plot:bool=False):
        test_result = run_FI_tester(method=method, plot=plot)

        if "figure" in list(test_result.keys()):
            self.figure = test_result["figure"]
        return test_result

    def assert_test_info(self, *args, **kwds):
        try:
            super(FITester, self).assert_test_info(*args, **kwds)
        finally:
            if self.figure is not None:
                del self.figure

if __name__ == "__main__":
    ntraces = 1
    methods = [
        "fitOneOriginal",
        # "FIGrowthExpBreak", # same as original
        "FIGrowthExp",
        # "piecewiselinear3",
       # "FIGrowthPower",
        "Hill",
        "slope",
    ]
    testmethod = None
    print("Len sys.argv: ", len(sys.argv))
    if len(sys.argv) <= 1:
        testmethod = "fitOneOriginal"

    if len(sys.argv) > 1:
        testmethod = sys.argv[1]
    if testmethod in ["all", "ALL"]:
        print("Testing ALL fits")
        for m in methods:
            print("testing: ", m)
            analysis_summary = run_FI_tester(method=m, plot=True)
        exit()
    if testmethod not in methods:
        print("Test for %s method is not implemented" % testmethod)
        exit(1)
    else:
        analysis_summary = run_FI_tester(method=testmethod, plot=True)
    